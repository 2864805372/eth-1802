1. day10复习
   1. solidity IDE安装
      1. remiex安装使用
   2. solidity solc的安装
      1. 通过npm安装
   3. solidity测试环境搭建
      1. testrpc：生成以太坊账号
      2. truffle开发框架：集开发、运行、部署、测试为一体的一个框架
      3. 安装方式：通过npm安装
   4. solidity基础语法
      1. 文档注释
      2. 值传递与引用传递
         1. 值类型与引用类型
      3. 整形
      4. 布尔
      5. 地址类型
         1. 属性:balance
         2. 方法:send()
      6. 定长字节数组
         1. bytes1~bytes32
         2. 步长
         3. 属性:length
      7. 字符串
      8. 智能推断:var
      9. 16进制 : hex 
      10. 常量和变量
      11. 数据位置
          1. memory:函数参数与返回值
          2. storage:状态变量与函数内部局部变量
      12. 枚举
      13. 结构体
          1. 初始化方式
          2. 在solidity中，函数不能直接返回结构体
      14. 数组
          1. 分类
          2. 属性
      15. 映射
      16. 类型转换
2. 控制语句
   1. 循环语句
      1. for
      2. while
      3. do-while
      4. continue,break
   2. 条件语句
      1. if-else
      2. 三目运算符
         1. 三目运算符也是一种条件判断语句
         2. 形式:a>b?bigger:smaller
3. 全局单位
   1. 在solidity中，有一些内建的全局变量，这些变量可以在合约的任何地方调用
   2. msg
   3. this
   4. tx
   5. block
4. 数据位置转换
   1. 在solidity中，数据位置有三类
      1. memory:存储在内存中
      2. storage:storage存储位置修饰的变量存储的数据是永久存在的，存储在区块链上面
      3. calldata:该位置的数据是只读的，不会被持久化到区块链上，一般只有外部函数会被指定
   2. 函数的参数，返回值默认位置是memory
   3. 函数局部变量，状态变量默认存储位置是storage
   4. 数据位置转换
      1. memory->memory：引用传递，目标变量值的修改会造成源变量的值修改
      2. memory->storage：值传递，目标变量值的修改不会影响到源变量值的内容
      3. storage->storage：引用传递
         1. 注意，如果以一个storage变量作为函数参数时，函数可见性只能是private/internal
      4. storage->memory：值传递
5. 函数基础
   1. solidity本身也是一门函数式编程编程语言，也就是说函数可以作为参数，变量，返回值
   2. 函数属于值类型，支持多返回值
   3. 调用方式
      1. 内部调用
         1. 内部调用采用EVM跳转调用，所以能够直接使用上下文中的数据，不需要拷贝，因此在数据传递的时候非常高效
         2. 对合约内的函数，引入的库函数以及从父合约中继承的函数，都可以进行内部调用
      2. 外部调用
         1. 采用外部调用，使用external.对于一个外部调用，所有函数参数都必须要拷贝到内存中
6. 函数定义类型
   1. view：只读，不会改变合约内部状态
      1. 修改状态操作如下：
         1. 写入状态变量，触发事件，创建其它合约，使用自毁函数，发送以太币，底层调用，内联汇编，调用任何没有被标记为view或者pure的函数
      2. 注意：如果view定义的函数中有状态变量的修改，不会报错，但是会给警告
   2. pure:只读，不会修改合约内部状态，也不能读取合约状态
      1. 除去view中的限制，还包括以下内容
         1. 读取状态变量，访问this.balance或者address.balance,访问bock,tx,msg中的任何成员(msg.sig, msg.data)， 调用任何一个没有被标记为pure的函数
7. 特殊函数
   1. 回退函数(fallback)
      1. 在每个合约里面，都会自动生成一个没有名字，没有参数，没有返回值的函数，这就是回退函数
      2. 作用
         1. 在调用合约时，没有匹配上任何一个函数
         2. 给合约发送eth的时候也调用，需要注意的是，如果合约没有定义回退函数的话，接收eth会触发异常
         3. 如果回退函数要接收eth，必须要有一个payable关键字
   2. 自毁函数
      1. 自毁函数可以摧毁当前的合约，如果说合约中原本有以太币存储，则会将以太币转移到给定的地址
      2. 如果合约在自毁之后还有人发送以太币到这个合约地址，那么这些以太币就会完全丢失，无法赎回
   3. 常函数
      1. 关键字constant
      2. 常函数不会修改区块链上的任何状态，没有强制的规定，但是会给一个警告
   4. 访问器(getter)
      1. 编译器会自动为所有public的状态变量创建访问器
      2. getter具有外部可见性。如果通过内部的方式访问，就直接当成了一个变量,如果通过外部方式访问,那就只能通过函数的方式进行调用
   5. 其它内置函数
      1. 数学函数
         1. addmod(x,y,k); // x + y 对k 取余 
         2. mulmod(x,y,k);  // x * y对k取余 
      2. 加密函数
         1. solidity中也包含了加密函数,实际上调用的是以太坊中的加密函数
8. 函数修改器(modifier)
   1. 修改器的作用是检查函数执行前某种前置条件是否满足
   2. 一个函数可以有多个修改器，多个修改之间用空格分开，修改器的等效顺序与定义顺序一样
   3. 修改器本身也是一种合约属性，可以被继承，也可以被子合约重写
9. 函数可见性或权限
   1. 函数权限指的是调用权限(谁有权利调用我们定义的函数)
   2. 分类
      1. 内部函数：internal
      2. 外部函数：external
      3. 私有函数：private
      4. 公有函数：public
   3. public:公有函数，可以通过内部，外部，消息进行调用。对于public状态变量，会自动创建一个访问器
   4. private:私有函数，私有函数只能在当前合约中访问，不能通过继承进行访问
   5. internal:不能够在当前合约的**上下文**环境之外执行，只能在当前合约环境之内进行调用。比如当前合约代码块中，内部的库函数中，继承的合约中。
   6. external:外部函数
      1. external可以用作外部函数调用的参数，或者由外部函数调用返回
      2. 可以通过其它合约
      3. 可以通过this调用，只要是通过this进行调用的都是在通过external的方式进行调用 
      4. 不能在内部调用
10. solidity面向对象
   1. 面向对象：一种编程思想(主要是与面向过程相比较)，OO编程
      1. 特点：封装，继承，多态
   2. solidity中的面向对象
      1. 继承
         1. 在solidity中，继承是就合约与合约的一种特殊的传递关系
         2. 通过"**is**"关键字实现实现继承。子合约可以访问父合约中所有非private的状态变量与函数
         3. 继承支持参数传递
         4. 支持多重继承，多个继承之间用逗号隔开，多重继承中不能有重名合约。如果一个合约继承了其它合约，在区块链上只会创建一个合约，所有父合约的代码都会通过拷贝的方式进行继承(也就是说父合约的代码拷贝到子合约中)
         5. 如果一个合约继承了多个父合约，而这多个父约中有同名函数，默认继承最后一个合约的函数，前面合约的同名函数都会被覆盖。如果需要调用指定父合约的函数，可以通过合约名称显示指定。
      2. 抽象
         1. 抽象可以分为抽象函数与抽象合约
         2. 抽象函数：如果一个函数没有函数体，那么该函数就是个抽象函数
         3. 抽象合约：如果一个合约包含了抽象函数，就是一个抽象合约
         4. 抽象不能够被编译，但是可以被继承
         5. 抽象类似于多态，子合约通过继承完成同名函数不同实现的功能
      3. 接口interface
         1. 如果说一个合约中只有抽象函数，那么该合约就是一个接口(需要注意接口和抽象的区别)
   3. 库(library)
      1. 在solidity中，库也是一种合约
      2. 区别
         1. 库没有存储，不存储以太币
         2. 没有payable关键字，没有fallback函数
         3. 库可以部署，但是不能够直接访问其中的函数
         4. 通常用于对一些需要进行复用的代码块进行封装，类似于golang package
      3. using for *(附着库)
         1. 声明方式：using A for B:将库A中定义的所有函数都附着在任意的一个类型B上面，类似B的任何实例都可以调用A中的所有方法
   4. import
      1. 概念：导入其它源文件，调用该源文件中的函数
      2. import "filename":把指定的文件导入到当前的全局范围之内